#!/usr/bin/env sh
# This script is part of Martin V\"ath's archwrap project.
set -u
. archwrap.sh

set -f

Usage() {
	Echo "Usage: ${0##*/} [options] [path/]zipdir[/][.tgz]
Create archive ./zipdir.tgz with contents of zipdir
-@ path  store output in path/zipdir.tgz
         The typical call is -@ user@machine: or -@ user@mach:/tmp/
         to use remote connection via rsh (GNU tar) resp. ssh (star)
-R PATH  store output in PATH; use e.g. -R - for piping to stdout
-g use gzip     (archivename is ./zipdir.tgz or ./zipdir.tar.gz)
-b use bzip2    (archivename is ./zipdir.tbz or ./zipdir.tar.bz2)
-l use lzma     (archivename is ./zipdir.tlz or ./zipdir.tar.lzma)
-L use xz       (archivename is ./zipdir.txz or ./zipdir.tar.xz)
-7 use 7z       (archivename is ./zipdir.t7z or ./zipdir.tar.7z)
-r use lrzip    (archivename is ./zipdir.tlr or ./zipdir.tar.lrz)
-t use Tar only (archivename is ./zipdir.tar)
-X use long names (.tar.gz instead of .tgz etc)
-x use short names (.tgz instead of .tar.gz etc)
-S use star instead of tar, ignore GNUTARVERSION
-T use tar instead of star (default)
-A do not store extended attributes (forced if unsupported by tar)
-C store as much as possible (Access Control Lists, creation time...)
-c be careful - avoid star -no-fsync; same as STAR_HAS_NOFSYNC=false
-F symbolic links are stored as such (default)
-f symbolic links are stored as files
-E break on error
-d pack also (parent) directory into archive, not only its content
-D pack (parent) directory as \".\" into archive, not only its content
-n store plain owner name
-p ignore GNUTARVERSION and STAR_HAS_NOFSYNC environment variables
-P print output appropriate for setting GNUTARVERSION and exit
-q be quiet"
	exit ${1:-1}
}

use_star=false
xattr=:
follow=false
control=false
withparent=false
dotparent=false
xnames=false
ownernum=:
sparse=:
remote=
errbreak=false
comp='g'
quiet=false
calc_version_only=false
case ${0##*/} in
*lzma*|*.*lz*)
	comp='l'
	xnames=:;;
*txz*)
	comp='x';;
*xz*)
	comp='x'
	xnames=:;;
*bzip*|*.*bz*)
	comp='b'
	xnames=:;;
*gzip*|*.*gz*)
	comp='g'
	xnames=:;;
*.*7z*)
	comp='7'
	xnames=:;;
*.*lr*)
	comp='r'
	xnames=:;;
*tbz*)
	comp='b';;
*tgz*)
	comp='g';;
*7z*)
	comp='7';;
*lz*)
	comp='l';;
*lr*)
	comp='r';;
*tar*)
	comp=;;
esac
OPTIND=1
while getopts 'qAF@:R:SETcCfdDnbg7lLzmrtpPsXxhH' opt
do	case $opt in
	q)	quiet=:;;
	A)	xattr=false;;
	F)	follow=false;;
	S)	use_star=:;;
	T)	use_star=false;;
	c)	STAR_HAS_NOFSYNC=;;
	C)	control=:;;
	E)	errbreak=:;;
	f)	follow=:;;
	d)	withparent=:
		dotparent=false;;
	D)	withparent=:
		dotparent=false;;
	n)	ownernum=;;
	t)	comp=;;
	p)	unset GNUTARVERSION STAR_HAS_NOFSYNC;;
	P)	calc_version_only=:;;
	s)	sparse=;;
	b)	comp=b;;
	g)	comp=g;;
	[lzm])	comp=l;;
	L)	comp=x;;
	7)	comp=7;;
	r)	comp=r;;
	X)	xnames=:;;
	x)	xnames=false;;
	'@')	remote=r
		remotepath=$OPTARG;;
	R)	remote=R
		remotepath=$OPTARG;;
	'?')	exit 1;;
	*)	Usage 0;;
	esac
done
shift $(( $OPTIND - 1 ))

if $calc_version_only
then	tarprg=
	CalcGnuTarVersion && printf '%s' "$GNUTARVERSION"
	exit
fi

[ $# -ne 0 ] || Usage

if [ -n "${remote:++}" ]
then	export RSH
	[ -n "${RSH:++}" ] || RSH=`command -v ssh 2>/dev/null`
fi

SetTarPrg
Push -c taropts '-c'
$quiet  || Push taropts '-v'
$follow && Push taropts '-h'

tarcomp=:
errfile=false
if $use_star
then	Push taropts '-H=exustar'
	# Push taropts '-H=pax'
	$xattr && Push taropts '-xattr'
	$control && Push taropts '-acl' '-xfflags'
	#Push taropts "-dirmode"
	$ownernum && Push taropts '-numeric'
	$sparse && Push taropts '-sparse'
	$STAR_HAS_NOFSYNC && Push taropts '-no-fsync'
	case $comp in
	g)	Push taropts '-z'
		STAR_COMPRESS_FLAG='--best'
		export STAR_COMPRESS_FLAG;;
	b)	Push taropts '-bz'
		STAR_COMPRESS_FLAG='-9'
		export STAR_COMPRESS_FLAG;;
	[xlr7])	tarcomp=false;;
	esac
else	$tar_knows_xattr && $xattr && Push taropts '--xattrs'
	$tar_knows_numeric_owner && $ownernum && Push taropts '--numeric-owner'
	$tar_knows_sort && Push taropts '--sort=name'
	$tar_knows_sparse && Push taropts '-S'
	$tar_knows_use_compress_program && case $comp in
	x)	Push taropts '--use-compress-program' "${0%/*}/xzbest";;
	b)	Push taropts '--use-compress-program' "${0%/*}/bzipbest";;
	g)	Push taropts '--use-compress-program' "${0%/*}/gzipbest";;
	7)	Push taropts '--use-compress-program' "${0%/*}/7zbest";;
	l)	Push taropts '--use-compress-program' "${0%/*}/lzmabest";;
	r)	tarcomp=false;;
	esac
fi
$tarcomp || ! $tar_needs_errfile || errfile=:
if $xnames
then	case $comp in
	g)	ext='tar.gz';;
	b)	ext='tar.bz2';;
	7)	ext='tar.7z';;
	l)	ext='tar.lzma';;
	x)	ext='tar.xz';;
	r)	ext='tar.lrz';;
	*)	ext='tar';;
	esac
else	case $comp in
	g)	ext='tgz';;
	b)	ext='tbz';;
	7)	ext='t7z';;
	l)	ext='tlz';;
	x)	ext='txz';;
	r)	ext='tlr';;
	*)	ext='tar';;
	esac
fi

Tarit() {
	if [ -z "${remote:++}" ]
	then	archive=$d/$name.$1
		rm -f -- "$archive"
	elif [ x"$remote" = x'r' ]
	then	archive=$remotepath$name.$1
	else	archive=$remotepath
	fi
	shift
	Cd "$dirname" || return
	stat=0
	if $errfile
	then	MkTemp || stat=$?
	fi
	if $withparent
	then	if $dotparent
		then	Push -c topack '.'
		else	Push -c topack "${name##*/}"
		fi
		Cd .. || stat=$?
	else	PushTopack || {
			stat=2
			Error $stat "not creating empty archive $archive"
		}
	fi
	[ $stat -eq 0 ] && if $errfile
	then	eval "\"\$tarprg\" \"\$@\" -f \"\$archive\" -- $topack 2>\"\$tempname\""
	else	eval "\"\$tarprg\" \"\$@\" -f \"\$archive\" -- $topack"
	fi || stat=$?
	if $errfile
	then	if test -s "$tempname"
		then	ErrMessage "tar of $name led to the following error message:"
			cat -- "$tempname" >&2
			[ $stat -eq 0 ] && stat=2
		fi
		RmTemp
	fi
	Cd "$d" || stat=$?
	[ $stat -ne 0 ] && Error $stat "error occured during tar of $name"
}

MainLoop() {
	d=$PWD
	for progargs
	do	dirname=$progargs
		while [ x"${dirname%/}" != x"$dirname" ]
		do	dirname=${dirname%/}
		done
		DoDir
	done
}

StripDirname() {
	for strip in taz tgz tbz dir tlz tlrz tlr
	do	case $dirname in
		*."$strip")
			dirname=${dirname%.*}
			return;;
		esac
	done
	for strip in z gz bz bz2 7z t7z lz lzm lzma lrz
	do	case $dirname in
		*.tar."$strip")
			dirname=${dirname%.*.*}
			return;;
		*."$strip")
			dirname=${dirname%.*}
			return;;
		esac
	done
}

unset za lrzip
DoDir() {
	StripDirname
	if [ -z "${dirname:++}" ] || ! test -d "$dirname"
	then	Error 2 "could not find Directory $dirname"
		return
	fi
	name=${dirname##*/}
	: ${name:=_}
	eval "set -- a $taropts"
	shift
	if $tarcomp
	then	Tarit "$ext" ${1+"$@"}
		return
	fi
	Tarit tar ${1+"$@"}
	case ${comp:-R} in
	R)	return;;
	g)	gzipbest -c -- "$archive" >"$name.$ext";;
	b)	bzipbest -k -c -- "$archive" >"$name.$ext";;
	7)	OptExternal za 7za
		"$za" a -- "$name.$ext" "$archive";;
	l)	lzmabest -k -c -- "$archive" >"$name.$ext";;
	x)	xzbest -k -c -- "$archive" >"$name.$ext";;
	r)	OptExternal lrzip
		"$lrzip" -L 9 -o "$name.$ext" -- "$archive";;
	esac || {
		Error $? "error when compressing $archive; keeping on disk" >&2
		return
	}
	rm -f -- "$archive"
}

MainLoop ${1+"$@"}
Exit
