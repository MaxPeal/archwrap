#!/usr/bin/env sh
# This script is part of Martin V\"ath's archwrap project.

. archwrap.sh

set -f

Usage() {
	Echo "Usage: ${0##*/} [options] [path/]zipdir[/][.tgz]
Create archive ./zipdir.tgz with contents of zipdir
 -@ path  Store output in path/zipdir.tgz
          The typical call is -@ user@machine: or -@ user@mach:/tmp/
          to use remote connection via rsh (GNU tar) resp. ssh (star)
 -R PATH  Store output in PATH. Use e.g. -R - for piping to standard output
 -g: Use gzip     (archivename is ./zipdir.tgz or ./zipdir.tar.gz)
 -b: Use bzip2    (archivename is ./zipdir.tbz or ./zipdir.tar.bz2)
 -l: Use lzma     (archivename is ./zipdir.tlz or ./zipdir.tar.lzma)
 -L: Use xz       (archivename is ./zipdir.txz or ./zipdir.tar.xz)
 -7: Use 7z       (archivename is ./zipdir.t7z or ./zipdir.tar.7z)
 -r: Use lrzip    (archivename is ./zipdir.tlr or ./zipdir.tar.lrz)
 -t: Use Tar only (archivename is ./zipdir.tar)
 -X: Use long names (.tar.gz instead of .tgz etc)
 -x: Use short names (.tgz instead of .tar.gz etc)
 -S: Use star instead of tar, ignore POORTAR, -p, -P
 -T: Use tar instead of star (default)
 -A: Do not store extended attributes (set POORTAR=xattr or semi for default)
 -C: Store as much as possible (Access Control Lists, creation time...)
 -c: Use secure mode (otherwise -no-fsync is used in star if possible)
 -F: Symbolic links are stored as such (default)
 -f: Symbolic links are stored as files
 -E: Break on error
 -d: Pack also (parent) directory into archive, not only its content
 -D: Pack (parent) directory as \".\" into archive, not only its content
 -n: Store plain owner name
 -p: Use poor tar (no compress pipe, xattr) (set POORTAR=1 for default)
 -s: Do not use the sparse option for tar (this is implied by -p)
 -P: Do not use poor tar"
	exit ${1:-1}
}

use_star=false
# command -v star >/dev/null 2>&1 && use_star=:
xattr=:
follow=false
control=false
withparent=false
dotparent=false
xnames=false
ownernum=:
sparse=:
secmode=false
remote=
errbreak=false
comp='g'
case ${0##*/} in
*lzma*|*.*lz*)
	comp='l'
	xnames=:;;
*txz*)
	comp='x';;
*xz*)
	comp='x'
	xnames=:;;
*bzip*|*.*bz*)
	comp='b'
	xnames=:;;
*gzip*|*.*gz*)
	comp='g'
	xnames=:;;
*.*7z*)
	comp='7'
	xnames=:;;
*.*lr*)
	comp='r'
	xnames=:;;
*tbz*)
	comp='b';;
*tgz*)
	comp='g';;
*7z*)
	comp='7';;
*lz*)
	comp='l';;
*lr*)
	comp='r';;
*tar*)
	comp=;;
esac
OPTIND=1
while getopts 'AF@:R:SETcCfdDnbg7lLzmrtpPsXxhH?' opt
do	case ${opt} in
	A)	xattr=false;;
	F)	follow=false;;
	S)	use_star=:;;
	T)	use_star=false;;
	c)	secmode=:;;
	C)	control=:;;
	E)	errbreak=:;;
	f)	follow=:;;
	d)	withparent=:
		dotparent=false;;
	D)	withparent=:
		dotparent=false;;
	n)	ownernum=;;
	t)	comp=;;
	p)	unset POORTAR;;
	P)	POORTAR=1;;
	s)	sparse=;;
	b)	comp=b;;
	g)	comp=g;;
	[lzm])	comp=l;;
	L)	comp=x;;
	7)	comp=7;;
	r)	comp=r;;
	X)	xnames=:;;
	x)	xnames=false;;
	'@')	remote=r
		remotepath=${OPTARG};;
	R)	remote=R
		remotepath=${OPTARG};;
	*)	Usage 0;;
	esac
done
shift $(( ${OPTIND} - 1 ))
[ ${#} -ne 0 ] || Usage

if [ -n "${remote:++}" ]
then	export RSH
	[ -n "${RSH:++}" ] || RSH=`command -v ssh 2>/dev/null`
fi

Push -c taropts '-c' '-v'
${follow} && Push taropts '-h'

${use_star} && unset POORTAR
poortar=:
case ${POORTAR:-n} in
[nNfF0lL]*)
	poortar=false;;
[xXsS]*)
	xattr=false
	poortar=false;;
esac
${poortar} && xattr=false
errfile=false
if ${use_star}
then	tarprg='star'
	Push taropts '-H=exustar'
	# Push taropts '-H=pax'
	${xattr} && Push taropts '-xattr'
	${control} && Push taropts '-acl' '-xfflags'
	#Push taropts "-dirmode"
	${ownernum} && Push taropts '-numeric'
	${sparse} && Push taropts '-sparse'
	case ${comp} in
	g)	Push taropts '-z'
		export STAR_COMPRESS_FLAG='--best';;
	b)	Push taropts '-bz'
		export STAR_COMPRESS_FLAG='-9';;
	[7lr])	poortar=:;;
	esac
	if ! ${secmode}
	then	"${tarprg}" -c -no-fsync >/dev/null 2>&1 && \
			Push taropts '-no-fsync'
	fi
else	MakeExternal tarprg tar
	${xattr} && Push taropts '--xattrs'
	${ownernum} && Push taropts '--numeric-owner'
	case ${comp} in
	g)	Push taropts '--use-compress-program' "${0%/*}/gzipbest";;
	b)	Push taropts '--use-compress-program' "${0%/*}/bzipbest";;
	7)	Push taropts '--use-compress-program' "${0%/*}/7zbest";;
	l)	Push taropts '--use-compress-program' "${0%/*}/lzmabest";;
	x)	Push taropts '--use-compress-program' "${0%/*}/xzbest";;
	r)	poortar=:;;
	esac
	if ${poortar}
	then	errfile=:
	else	${sparse} && Push taropts '-S'
	fi
fi
if ${xnames}
then	case ${comp} in
	g)	ext='tar.gz';;
	b)	ext='tar.bz2';;
	7)	ext='tar.7z';;
	l)	ext='tar.lzma';;
	x)	ext='tar.xz';;
	r)	ext='tar.lrz';;
	*)	ext='tar';;
	esac
else	case ${comp} in
	g)	ext='tgz';;
	b)	ext='tbz';;
	7)	ext='t7z';;
	l)	ext='tlz';;
	x)	ext='txz';;
	r)	ext='tlr';;
	*)	ext='tar';;
	esac
fi

Tarit() {
	if [ -z "${remote:++}" ]
	then	archive="${d}/${name}.${1}"
		rm -f -- "${archive}"
	elif [ "$remote" = 'r' ]
	then	archive="${remotepath}${name}.${1}"
	else	archive="${remotepath}"
	fi
	shift
	Cd "${dirname}" || return
	stat=0
	if ${errfile}
	then	MkTemp || stat=${?}
	fi
	if ${withparent}
	then	if ${dotparent}
		then	Push -c topack '.'
		else	Push -c topack "${name##*/}"
		fi
		Cd .. || stat=${?}
	else	PushTopack || {
			stat=2
			Error ${stat} "not creating empty archive ${archive}"
		}
	fi
	[ ${stat} -eq 0 ] && if ${errfile}
	then	eval "\"\${tarprg}\" \"\${@}\" -f \"\${archive}\" -- ${topack} 2>\"\${tempname}\""
	else	eval "\"\${tarprg}\" \"\${@}\" -f \"\${archive}\" -- ${topack}"
	fi || stat=${?}
	if ${errfile}
	then	if test -s "${tempname}"
		then	ErrMessage "tar of ${name} led to the following error message:"
			cat -- "${tempname}" >&2
			[ ${stat} -eq 0 ] && stat=2
		fi
		RmTemp
	fi
	Cd "${d}" || stat=${?}
	[ ${stat} -ne 0 ] && Error ${stat} "error occured during tar of ${name}"
}

MainLoop() {
	d=${PWD}
	for progargs
	do	dirname=${progargs}
		while [ "${dirname%/}" != "${dirname}" ]
		do	dirname=${dirname%/}
		done
		DoDir
	done
}

StripDirname() {
	for strip in taz tgz tbz dir tlz tlrz tlr
	do	case ${dirname} in
		*."${strip}")
			dirname=${dirname%.*}
			return;;
		esac
	done
	for strip in z gz bz bz2 7z t7z lz lzm lzma lrz
	do	case ${dirname} in
		*.tar."${strip}")
			dirname=${dirname%.*.*}
			return;;
		*."${strip}")
			dirname=${dirname%.*}
			return;;
		esac
	done
}

unset za lrzip
DoDir() {
	StripDirname
	if [ -z "${dirname:++}" ] || ! test -d "${dirname}"
	then	Error 2 "could not find Directory ${dirname}"
		return
	fi
	name=${dirname##*/}
	: ${name:=_}
	eval "set -- ${taropts}"
	if ! ${poortar}
	then	Tarit "${ext}" "${@}"
		return
	fi
	Tarit tar "${@}"
	case ${comp:-R} in
	R)	return;;
	g)	gzipbest -c -- "${archive}" >"${name}.${ext}";;
	b)	bzipbest -k -c -- "${archive}" >"${name}.${ext}";;
	7)	OptExternal za 7za
		"${za}" a -- "${name}.${ext}" "${archive}";;
	l)	lzmabest -k -c -- "${archive}" >"${name}.${ext}";;
	x)	xzbest -k -c -- "${archive}" >"${name}.${ext}";;
	r)	OptExternal lrzip
		"${lrzip}" -L 9 -o "${name}.${ext}" -- "${archive}";;
	esac || {
		Error ${?} "error when compressing ${archive}; keeping on disk" >&2
		return
	}
	rm -f -- "${archive}"
}

MainLoop "${@}"
Exit
